% Yampa-IY.tex
\begin{hcarentry}[updated]{Yampa}
\report{Ivan Perez}%11/18
\label{yampa}
\makeheader

Yampa (Github: \href{http://git.io/vTvxQ}{http://git.io/vTvxQ}, Hackage:
\href{http://goo.gl/JGwycF}{http://goo.gl/JGwycF}), is a Functional Reactive
Programming implementation in the form of a EDSL to define \emph{Signal
Functions}, that is, transformations of input signals into output signals
(aka. \emph{behaviours} in other FRP dialects).

Yampa systems are defined as combinations of Signal Functions. Yampa includes
combinators to create constant signals, apply pointwise (or time-wise)
transformations, access the running time, introduce delays and create
loopbacks (carrying present output as future input). Systems can be
dynamic: their structure can be changed using \emph{switching}
combinators, which apply a different signal function at some point in
the future. Combinators that deal with collections enable adding,
removing, altering, pausing and unpausing signal functions at will.

A suitable thinking model for FRP in Yampa is that of signal
processing, in which components (signal functions) transform signals
based on their present value and a component's internal state.
Components can, therefore, be serialized, applied in parallel, etc.
Yampa's signal functions implement the Arrow and ArrowLoop
typeclasses, making it possible to use both arrow notation and arrow
combinators.

Yampa combinators guarantee \emph{causality}: the value of an output
signal at a time $t$ can only depend on values of input signals at
times $[0,t]$. Efficiency is provided by limiting history only to the
immediate past, and letting signals functions explicitly carry
\emph{state} for the future.  Unlike other implementations of FRP,
Yampa enforces a strict separation of effects and pure
transformations: all IO code must exist outside Signal Functions,
making systems easier to reason about and debug.

Yampa has been used to create both free/open-source and commercial games.
Examples of the former include Frag
(\href{http://goo.gl/8bfSmz}{http://goo.gl/8bfSmz}), a basic reimplementation
of the Quake III Arena engine in Haskell, and Haskanoid
(\href{http://git.io/v8eq3}{http://git.io/v8eq3}), an arkanoid game featuring
SDL graphics and sound with Wiimote \& Kinect support, which works on Windows,
Linux, Mac, Android, iOS and web browsers (thanks to GHCJS). Examples of the
latter include Keera Studios' Magic Cookies!, a Haskell puzzle board game for
iOS and Android available on iTunes
(\href{https://goo.gl/6gB6sb}{https://goo.gl/6gB6sb})
% https://itunes.apple.com/us/app/magic-cookies/id1244709871
and Google Play
(\href{https://goo.gl/0A8z6i}{https://goo.gl/0A8z6i}), and the upcoming
games Pang-a-lambda and NPuzzles, also by Keera Studios.

%**<img width=700 src="./android.gif">
%*ignore
\begin{center}
\includegraphics[width=.7\columnwidth]{html/android.png}
% \caption{Screenshot of Yampa game Haskanoid running on Android.}
\end{center}
%*endignore

Guerric Chupin (ENSTA ParisTech), under the supervision of Henrik Nilsson
(Functional Programming Lab, University of Nottingham~\cref{nottingham}) has
developed Arpeggigon~\cref{arpeggigon}
(\href{https://gitlab.com/chupin/arpeggigon}{https://gitlab.com/chupin/arpeggigon}),
an interactive cellular automaton for composing groove-based music. The aim
was to evaluate two reactive but complementary frameworks for implementing
interactive time-aware applications. Arpeggigon uses Yampa for music
generation, Gtk2HS for Graphical User Interface, jack for handling MIDI I/O,
and Keera Hails to implement a declarative MVC architecture, based on
\emph{Reactive Values and Relations} (RVRs). The results have been written up
in an application paper, \emph{Funky Grooves: Declarative Programming of
Full-Fledged Musical Applications}, presented at PADL 2017. The code and an
extended version of the paper are publicly available
(\href{https://gitlab.com/chupin/arpeggigon}{https://gitlab.com/chupin/arpeggigon}).
Arpeggigon has also been demonstrated at FARM 2017, the Haskell eXchange 2017,
and Haskell in Leipzig 2017.

%**<img width=700 src="./arpeggigon.png">
%*ignore
\begin{center}
  \includegraphics[width=.7\columnwidth]{html/arpeggigon.png}
  % \caption{Screenshot of Guerric Chupin's Arpeggigon, which combines Reactive Values
  % and FRP.}
\end{center}
%*endignore

Yampa is under active development, with many Haskellers participating and
sending their contributions. Recent releases have featured a much smaller and
cleaner API, a testing extension based on Temporal Logic with QuickCheck, new
Signal Function combinators, and full documentation. We have also included more
examples of work with different backends, including SDL, SDL2, OpenGL,
Diagrams, Gloss, HTML DOM, HTML5 Canvas and WX. Our github repository includes
development branches with features that have been used for custom games, some
presented in the Haskell Symposium 2017 paper ``Back to the Future: time travel
in FRP''. Yampa will now be extended with systematic benchmarking using an
approach inspired by Martin Handley's AutoBench.

We are working on extensions to make Yampa more general and modular, increase
performance, enable new use cases and address existing limitations.  In 2016 we
published, together with Manuel B\"arenz, a monadic arrowized reactive
framework called Dunai (\href{https://git.io/vXsw1}{https://git.io/vXsw1}), and
a minimal FRP implementation called BearRiver. BearRiver provides all the core
features of Yampa, as well as additional extensions. We have demonstrated the
usefulness of our approach and the compatibility with existing Yampa games by
using BearRiver to compile and execute the Haskanoid and Magic Cookies! for
Android without changing the code of such games.  To collaborate with our
research, please contact Ivan Perez
(\href{mailto:ivan.perez@acm.org}{ivan.perez@acm.org}) or Henrik Nilsson
(\href{mailto:nhn@cs.nott.ac.uk}{nhn@cs.nott.ac.uk}).

There are several other channels that anyone can use to reach other Yampa users
and implementors, including a
\href{http://mailman.cs.yale.edu/mailman/listinfo/yampa-users}{mailing list}
and the \texttt{\#yampa} IRC channel on freenode. We are also active on Haskell
Caf\'e and the facebook group
\href{https://www.facebook.com/groups/programming.haskell/}{Programming
    Haskell}, and subscribe to the Yampa keyword on StackOverflow. We encourage
all Haskellers to participate on Yampa's development by opening issues on our
Github page (\href{http://git.io/vTvxQ}{http://git.io/vTvxQ}), adding
improvements, creating tutorials and examples, and using Yampa in their next
amazing Haskell games. We thank the kind users who have already sent us their
contributions.
\end{hcarentry}
